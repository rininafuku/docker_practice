・Dockerって何？
環境差分を吸収してくれるサービス
OS,ライブラリ,アプリをセットで提供してくれる
テスト環境や本番環境の差分も吸収する

・Dockerの流れ
dockerイメージ作成 =>イメージbuild => コンテナが生成される =>　コンテナを起動
イメージ作成は2パターン
  Dockerfileを自身で作成
  Dockerレジストリからイメージを取得

イメージにはアプリ,OSやDockerの設定を定義
イメージで定義したOSの中でアプリが実行される

・docker run hello-worldでコンテナを動かしたとき
docker run hello-worldコマンドでHello from Docker!と表示される。
=> もともと用意してあったイメージを取得
=> イメージをbuildしてコンテナ生成が生成される。
=> コンテナが起動
=> Hello from Docker!と表示される
この一連の流れが行われた。

・docker run hello-world裏側の処理
クライアントがdockerデーモンに要求を伝える
デーモンがhello-worldイメージを探す
まず、ローカルから要求されたイメージを探す
見つからない場合、Dockerレジストリからイメージを取得
イメージを取得できたらコンテナ起動までを行う。


・Dockerイメージ作成/コンテナ起動
まず、イメージを生成するためのDockerfileを作成
------
FROM : ベースのOS(ディストリビューション)を指定する
COPY : ローカルのアプリケーションコードをDockerにコピーする
RUN : イメージのbuild時に実行するコマンドを記載
      指定したOS上で使用できるコマンドで、イメージbuild時に行いたい操作コマンドを記載
CMD : コンテナ起動時に実行するコマンド
------
次に、イメージを生成する[docker image build -t hello:latest .]
イメージが生成できたらコンテナを生成/起動する[docker container run hello:latest]
=>コンテナが起動してアプリケーションコードが実行される

※補足
イメージとコンテナidがそれぞれ存在する(lsで確認できる)
イメージbuild時にタグと名前を指定する（-t hello:latest）

・Dockerと他の仮想化ソフトウェアの違い
DockerはOSを完全に再現できていない。
他の仮想化ソフトウェアはOSを完全に再現している。
そのため、Dockerは動作が軽く搬帰性も高い。

・イメージのビルド
docker image build [dockerfile]
-t namespace/イメージ名:タグ名でタグを付与できる

・コンテナ作成/起動
docker container run [イメージ]
-d　でバックグラウンドで実行できる
--name コンテナ名を付けれる
-it コンテナを起動させたままにできる
コンテナ上で最初に実行されるプロセスがシェルの場合（つまりCMDにシェルのコマンドが指定されている場合）、-itオプションをつけるとコンテナが起動したまま維持される。

※補足
重複するコンテナ名でbuildするとコンフリクトしてエラーになる。


・Dockerのネットワーク
ホストとコンテナのネットワークはそれぞれ独立している
なぜ？
コンテナごとにネットワークを独立させることで、1つの独立した仮想マシンとして振る舞えるようにするため。

ホストのポート番号とコンテナのapacheのポート番号をマッピングすることでネットワークを公開できる
クライアントからリクエストがホストにくる。ホストがコンテナのapacheにリクエストを送る。これを実現させる。
公開方法：コンテナ生成時にpublish（-pオプション）でホストとコンテナのapacheをマッピングする
        docker container run -p (ホストのport)8080:(コンテナのport)80 イメージ名

・コンテナのログ確認
docker container logs コンテナ名
コンテナが予期しない挙動をした時にログを確認して原因を探る

・起動中のコンテナでコマンドを実行する
docker container exec コンテナ名 /bin/bash
  apacheという名前のDockerコンテナでBashシェルを開始するという意味

どんなときに使う？
コンテナ内のシェルにアクセスしたいとき
コンテナ内でコマンドを実行したいとき：アプリケーションファイルの実行など
コンテナ内の設定の変更したいとき

※補足
シェルのコマンドを実行する場合は -itオプションを使用する
bashが起動して直ぐに終了するため、連動してコンテナも終了してしまう。

・Dockerfileのインストラクション
FROM : Dockerイメージのベースを指定する
COPY : ローカルのアプリケーションコードをDockerにコピーする
RUN : イメージのbuild時にコンテナ内で実行するコマンドを記載
      ここでライブラリのインストールなどを行う
CMD : コンテナ起動時に実行するコマンド

・シェルと-itオプションについて
docker run時にDockerfileでシェルを起動して何もしないと、シェルはすぐに終了するためコンテナも終了する
しかし、-itオプションをつけてdocker runを実行すると、コンテナはシェルが終了するまで継続して実行される。
なぜなら、ターミナルが表示され、ユーザーがコマンドを入力できる状態が保たれるため。

※補足
Dockerfile
-----
FROM ubuntu:22.04
-----
Dockerfileにイメージのベースだけを定義して、コンテナを起動するとbashが起動する。
シェルはすぐに終了するためコンテナも終了する。
しかし、コンテナ起動時に-itオプションを付けると、itオプションがコンテナのシェルに対してターミナルを提供してくれるので対話することができる。
つまり、-itオプションを付けるとコンテナ起動時にコンテナ内の操作モードになる。(-dオプションを付けていると、対話モードではなくコマンドラインに戻る。)
https://chat.openai.com/c/654f9c9b-19e2-4280-9e39-76ec246532c9

・なぜコンテナでapacheを起動するとコンテナが終了するのか
コンテナが起動し続けるためにはメインプロセスが実行し続けてる必要がある。
ただ、apacheを起動するプロセスはバックグラウンドで実行されメインプロセスが実行されていないためコンテナが終了した。
------------
FROM ubuntu:22.04
RUN apt update \
    && apt install -y apache2
CMD [ "service" "apache2" "start" ]
------------

解決策
apacheの起動をメインプロセス（FOREGROUND）で行う。
CMD [ "apachectl" "-D" "FOREGROUND" ]

※補足
FOREGROUNDでapacheを起動するとコマンドラインが使えなくなるので-dオプションでデタッチモードにすること

・dockerfileの作成手順
ベースイメージを決める
Dockerコンテナの中に入る
必要な作業を行う（コマンドが動くか確認）
Dockerfileに記載する
イメージとコンテナを作る


FROMでapacheベースを定義
コンテナを起動して動作確認に進む
ubuntuはbashを使用しているのでコンテナ起動してもすぐに終了する
なのでitオプションを使う。-dでバックグラウンドで動作させる。マッピングする。
apacheのインストールをする
apacheをstartさせる
apacheのstatusを確認する

apacheはvar/www/htmlのindex.htmlを参照するようになっている
COPYコマンドでhtml配下にトップページをおく

docker composeとは？
