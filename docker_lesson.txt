・Dockerって何？
環境差分を吸収してくれるサービス
OS,ライブラリ,アプリをセットで提供してくれる
テスト環境や本番環境の差分も吸収する

・Dockerの流れ
dockerイメージ作成 =>イメージbuild => コンテナが生成される =>　コンテナを起動
イメージ作成は2パターン
  Dockerfileを自身で作成
  Dockerレジストリからイメージを取得

イメージにはアプリ,OSやDockerの設定を定義
イメージで定義したOSの中でアプリが実行される

・docker run hello-worldでコンテナを動かしたとき
docker run hello-worldコマンドでHello from Docker!と表示される。
=> もともと用意してあったイメージを取得
=> イメージをbuildしてコンテナ生成が生成される。
=> コンテナが起動
=> Hello from Docker!と表示される
この一連の流れが行われた。

・docker run hello-world裏側の処理
クライアントがdockerデーモンに要求を伝える
デーモンがhello-worldイメージを探す
まず、ローカルから要求されたイメージを探す
見つからない場合、Dockerレジストリからイメージを取得
イメージを取得できたらコンテナ起動までを行う。


・Dockerイメージ作成/コンテナ起動
まず、イメージを生成するためのDockerfileを作成
------
FROM : ベースのOS(ディストリビューション)を指定する
COPY : ローカルのアプリケーションコードをDockerにコピーする
RUN : イメージのbuild時に実行するコマンドを記載
      指定したOS上で使用できるコマンドで、イメージbuild時に行いたい操作コマンドを記載
CMD : コンテナ起動時に実行するコマンド
------
次に、イメージを生成する[docker image build -t hello:latest .]
イメージが生成できたらコンテナを生成/起動する[docker container run hello:latest]
=>コンテナが起動してアプリケーションコードが実行される

※補足
イメージとコンテナidがそれぞれ存在する(lsで確認できる)
イメージbuild時にタグと名前を指定する（-t hello:latest）

・Dockerと他の仮想化ソフトウェアの違い
DockerはOSを完全に再現できていない。
他の仮想化ソフトウェアはOSを完全に再現している。
そのため、Dockerは動作が軽く搬帰性も高い。

・イメージのビルド
docker image build [dockerfile]
-t namespace/イメージ名:タグ名でタグを付与できる

・コンテナ作成/起動
docker container run [イメージ]
-d　でバックグラウンドで実行できる
--name コンテナ名を付けれる
-it コンテナを起動させたままにできる
コンテナ上で最初に実行されるプロセスがシェルの場合（つまりCMDにシェルのコマンドが指定されている場合）、-itオプションをつけるとコンテナが起動したまま維持される。

※補足
重複するコンテナ名でbuildするとコンフリクトしてエラーになる。


・Dockerのネットワーク
ホストとコンテナのネットワークはそれぞれ独立している
なぜ？
コンテナごとにネットワークを独立させることで、1つの独立した仮想マシンとして振る舞えるようにするため。

ホストのポート番号とコンテナのapacheのポート番号をマッピングすることでネットワークを公開できる
クライアントからリクエストがホストにくる。ホストがコンテナのapacheにリクエストを送る。これを実現させる。
公開方法：コンテナ生成時にpublish（-pオプション）でホストとコンテナのapacheをマッピングする
        docker container run -p (ホストのport)8080:(コンテナのport)80 イメージ名

・コンテナのログ確認
docker container logs コンテナ名
コンテナが予期しない挙動をした時にログを確認して原因を探る

・起動中のコンテナでコマンドを実行する
docker container exec コンテナ名 /bin/bash
  apacheという名前のDockerコンテナでBashシェルを開始するという意味

どんなときに使う？
コンテナ内のシェルにアクセスしたいとき
コンテナ内でコマンドを実行したいとき：アプリケーションファイルの実行など
コンテナ内の設定の変更したいとき
※補足
シェルのコマンドを実行する場合は -itオプションを使用する
bashが起動して直ぐに終了するため、連動してコンテナも終了してしまう。


・dockerfileの作成手順
ベースイメージを決める
Dockerコンテナの中に入る
必要な作業を行う（コマンドが正しく動くか確認）
動作したコマンドをDockerfileに記載する
イメージとコンテナを作る


・Dockerfileのインストラクション
FROM : Dockerイメージのベースを指定する
COPY : ローカルのアプリケーションコードをDockerイメージにコピーする
RUN : イメージのbuild時にコンテナ内で実行するコマンドを記載
      ここでライブラリのインストールなどを行う
CMD : コンテナ起動時に実行するコマンド


・シェルと-itオプションについて
docker run時にDockerfileでシェルを起動して何もしないと(ベースだけを定義すると)、シェルはすぐに終了するためコンテナも終了する
しかし、-itオプションをつけてdocker runを実行すると、コンテナは起動状態のまま維持される。
なぜなら、コンテナ内でシェルが起動している状態が維持されているため。
-itオプションを使用するとシェルプロセスが終了せずに、メインプロセスで走っている状態になる。

https://chat.openai.com/c/654f9c9b-19e2-4280-9e39-76ec246532c9


・なぜコンテナでapacheを起動するとコンテナが終了するのか
コンテナが起動し続けるためにはメインプロセスが実行し続けてる必要がある。
ただ、apacheを起動するプロセスはバックグラウンドで実行されメインプロセスが実行されていないためコンテナが終了した。
------------
FROM ubuntu:22.04
RUN apt update \
    && apt install -y apache2
CMD [ "service" "apache2" "start" ]
------------

解決策
apacheの起動をメインプロセス（FOREGROUND）で行う。
CMD [ "apachectl" "-D" "FOREGROUND" ]

※補足
FOREGROUNDでapacheを起動するとコマンドラインが使えなくなるので-dオプションでデタッチモードにすること

・COPYインストラクション
ローカルファイルをDockerイメージにコピーする
apacheは/var/www/html/のindex.htmlを参照するようになっているので、COPYコマンドでhtml配下にトップページをおく
これで、apacheとマッピングされているlocalhostポートにアクセスするとindex.htmlが表示される。

・ENVインストラクション
環境変数を管理するインストラクション
Dockerfileとコンテナ内で使える。

ARGインストラクションはビルド時にユーザーが渡せる変数。
Dockerfileで使える。

・WORKDIRインストラクション
RUNなどのコマンドを実行する作業ディレクトリを指定できる

・Dockerfileのベストプラクティス
イメージを軽量にするため、イメージのビルド時に不要なファイルをビルドコンテキストから.dockerignoreファイルで除外すべき。
  ビルとコンテキストとは？
  dockerイメージをビルド時のワーキングディレクトリのこと。
  dockerイメージ作成時にビルドコンテキスト以下の全てのディレクトリをdockerデーモンに転送している。

コンテナの再利用などのため、1つのコンテナでは１つのプロセスだけ実行する
  phpとmysqlがあったらそれぞれコンテナを作成する。

イメージサイズを小さくする
  必須でないパッケージをインストールしない
  ベースイメージを小さいものにする
  RUNを纏める
  マルチステージビルドを使う:https://chat.openai.com/?model=gpt-4

docker composeとは？
